[ { "title": "C++ move semantics benefits", "url": "/posts/move-semantics/", "categories": "C++", "tags": "c++, move semantics", "date": "2022-12-15 21:10:00 +0100", "snippet": "In a previous post, I talked about every kind of constructors modern C++ offers. I briefly introduces move constructors. Here I’m going to explain move semantics and why it’s so useful.Comparing the Performance of Copying and Moving std::string ObjectsC++11 introduced the std::move function, which allows objects to be moved instead of copied. Moving an object is more efficient than copying it because it involves simply transferring ownership of the object’s underlying resources, rather than creating a new copy of the object’s data. However, not all objects can be moved, and in some cases, it may still be more efficient to copy an object instead of moving it.In this blog post, we will compare the performance of copying and moving std::string objects, which are a common type of object that can be moved in C++. We will use a simple benchmark to measure the time it takes to copy and move std::string objects of various sizes, and we will discuss the implications of the benchmark results.Benchmark SetupTo compare the performance of copying and moving std::string objects, we will use the following benchmark setup: We will use the std::chrono library to measure the elapsed time of each operation. We will create a std::string object of a reasonable size. We will measure the time it takes to copy and move each std::string object N times.Bench code#include &lt;string&gt;#include &lt;chrono&gt;#include &lt;iostream&gt;using namespace std::chrono;constexpr int N = 100000;int main(){ // measure the time it takes to copy the string N times auto start = high_resolution_clock::now(); for (int i = 0; i &lt; N; ++i) { std::string str = \"this is a test string. Let's make it long so the compiler cannot optimize it.\"; std::string copy = str; } auto end = high_resolution_clock::now(); auto copy_time = duration_cast&lt;microseconds&gt;(end - start); // measure the time it takes to move the string N times start = high_resolution_clock::now(); for (int i = 0; i &lt; N; ++i) { std::string str = \"this is a test string. Let's make it long so the compiler cannot optimize it.\"; std::string moved = std::move(str); } end = high_resolution_clock::now(); auto move_time = duration_cast&lt;microseconds&gt;(end - start); // print the results std::cout &lt;&lt; \"Copy time: \" &lt;&lt; copy_time.count() &lt;&lt; \" microseconds\\n\"; std::cout &lt;&lt; \"Move time: \" &lt;&lt; move_time.count() &lt;&lt; \" microseconds\\n\"; return 0;}Note: for each test I declare an instance of str. While this is clearly sub-optimal in a real-world context, there is a reason why in this particular one. Indeed, when str is moved to moved, its content is transfered. Creating str outside the loop would result in the string being moved on the first time, then only an empty shell for each next turn, making the results wrong.Benchmark ResultsAfter running the program a few times, I obtained the following result: Version Average time (microseconds) Copy 801 Move 438 First conclusionWith this first example, we can see how our code benefits from move semantics: moving an object instead of copying if take way, way less time.But wait, there is more…std::string can contain way more than a few words.Pushing std::string a bit furtherAbout std::string’s capacityThe maximum capacity of a std::string object is determined by the amount of memory available on the system. This means that the maximum capacity of a std::string object can vary depending on the hardware and software environment in which the program is run.In general, the maximum capacity of a std::string object is the largest value that can be represented by the size_type of the std::string class, which is an implementation-defined unsigned integer type. For example, on many systems, the size_type of std::string is an unsigned int, which means that the maximum capacity of a std::string object is the largest value that can be represented by an unsigned int, which is typically around 4 billion on a 32-bit system and around 18 billion on a 64-bit system.However, even if the maximum capacity of a std::string object is very large, it is important to note that the actual amount of memory that can be allocated for a std::string object is limited by the amount of available memory on the system. This means that even if the maximum capacity of a std::string object is very large, it may not be possible to create a std::string object with that capacity if there is not enough memory available on the system.In general, it is recommended to avoid creating very large std::string objects, as they can consume a significant amount of memory and may cause performance issues. Instead, it is often better to use other data structures, such as std::vector, which can dynamically resize their internal storage as needed without consuming excessive amounts of memory.Testing move vs copy with increasingly large std::stringLet’s reuse the previous code, but this time with small to huge std::string instances:#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;chrono&gt;const uint64_t STR_LENGTHS[] = { 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};void test_move_copy(std::string &amp;str){ // Measure the time it takes to copy the string auto start = std::chrono::high_resolution_clock::now(); std::string copied_str = str; auto end = std::chrono::high_resolution_clock::now(); auto elapsed_copy = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); // Measure the time it takes to move the string start = std::chrono::high_resolution_clock::now(); std::string moved_str = std::move(str); end = std::chrono::high_resolution_clock::now(); auto elapsed_move = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); // Output the results std::cout &lt;&lt; \"Copy time: \" &lt;&lt; elapsed_copy.count() &lt;&lt; \" microseconds\" &lt;&lt; std::endl; std::cout &lt;&lt; \"Move time: \" &lt;&lt; elapsed_move.count() &lt;&lt; \" microseconds\" &lt;&lt; std::endl;}int main(){ // Test move vs copy for strings of different lengths for (auto length : STR_LENGTHS) { std::cout &lt;&lt; \"String length: \" &lt;&lt; length &lt;&lt; std::endl; std::string str(length, 'x'); test_move_copy(str); std::cout &lt;&lt; std::endl; } return 0;}ResultsThis chart clearly demonstrates the benefits of move semantics when using very large objects. Copying an instance of std::string takes a linear amount of time. Moving, however, takes a constant, almost negligible amount of time." }, { "title": "C++ objects lifetime", "url": "/posts/Cpp-object-lifetime/", "categories": "C++", "tags": "c++, object lifetime", "date": "2022-12-15 12:51:00 +0100", "snippet": "Object lifetime in C++ refers to the time during which an object exists and is accessible in a program. Understanding object lifetime is important because it affects the behavior of a program and can impact the performance of the code. In this blog post, we will discuss object lifetime in C++ and the different types of constructors and destructors that are used to manage object lifetime.Disclaimer: in what follows I will use {fmt} instead of iostream. I encourage you to do the same.Object Lifetime in C++In C++, objects are created when they are instantiated using the new keyword or by declaring a variable with a class type. For example:// Create an object using the new keywordExampleClass* obj1 = new ExampleClass();// Create an object by declaring a variableExampleClass obj2;The lifetime of an object begins when it is created and ends when it is destroyed. The lifetime of an object can be controlled using constructors and destructors.Constructors in C++A constructor is a special member function of a class that is called automatically when an object of that class is created. Constructors are used to initialize the member variables of an object and to perform other tasks that are needed to set up the object for use.There are several different types of constructors in C++, including the default constructor, the copy constructor, and the move constructor.Default ConstructorA default constructor is a constructor that takes no arguments and is called when an object is created without specifying any arguments. For example:class ExampleClass {public: // Default constructor ExampleClass() { // Initialize member variables here }};// Call default constructorExampleClass obj1;Copy ConstructorA copy constructor is a constructor that takes a reference to an object of the same class as the constructor and is called when an object is created by copying another object. For example:class ExampleClass {public: // Copy constructor ExampleClass(const ExampleClass&amp; other) { // Copy member variables from other object here }};// Call default constructorExampleClass obj1;// Call copy constructorExampleClass obj2 = obj1;Move ConstructorA move constructor is a constructor that takes a reference to an object of the same class as the constructor and is called when an object is created by moving another object. For example:class ExampleClass {public: // Move constructor ExampleClass(ExampleClass&amp;&amp; other) { // Move member variables from other object here }};// Call default constructorExampleClass obj1;// Call move constructorExampleClass obj2 = std::move(obj1);In this case, the guts of obj1 are transfered to obj2, leaving obj1 as an empty shell. Let’s illustrate with a simple example involving an std::string:#include &lt;fmt/core.h&gt;#include &lt;string&gt;int main() { // Create a string std::string s1{\"Foo\"}; fmt::print(\"s1 = {}\\n\", s1); // Move it to another string std::string s2{std::move(s1)}; fmt::print(\"s1 = {}\\n\", s1); fmt::print(\"s2 = {}\\n\", s2); return 0;}When executed, the following code produces this output:s1 = Foos1 =s2 = FooWe can see that after s1 has been moved using std::move, its content have been moved to s2. s1 is thus an useless shell now.To get a better understanding of how move can be used to improve performance, consider reading this post.Destructors in C++A destructor is a special member function of a class that is called automatically when an object of that class is destroyed. Destructors are used to perform clean-up tasks, such as releasing memory that was allocated by the object.class ExampleClass {public: // Destructor ~ExampleClass() { // Perform clean-up tasks here }};Object lifetime classOk now let’s summarize everything, give our class a better name and a property. We will use this property to track our instances.class LifetimeObserver {private: uint8_t a;public: LifetimeObserver():a{0} { fmt::print(\"No parameter constructor (a={})\\n\", a); } LifetimeObserver(uint8_t parameter):a{parameter} { fmt::print(\"Parameter constructor (a={})\\n\", a); } LifetimeObserver([[maybe_unused]] const LifetimeObserver&amp; lto) { fmt::print(\"Copy constructor (a={})\\n\", a); } LifetimeObserver([[maybe_unused]] const LifetimeObserver&amp;&amp; lto) { fmt::print(\"Move constructor (a={})\\n\", a); } ~LifetimeObserver() { fmt::print(\"Destructor (a={})\\n\", a); }};The [[maybe_unused]] attribute silences compiling errors complaining that the parameter is not used in the function’s body.Fooling aroundHere is a complete example to make a good use of the LifetimeObserver class:#include &lt;fmt/core.h&gt;#include &lt;string&gt;#include &lt;memory&gt;class LifetimeObserver {private: uint8_t a;public: LifetimeObserver():a{0} { fmt::print(\"No parameter constructor (a={})\\n\", a); } LifetimeObserver(uint8_t parameter):a{parameter} { fmt::print(\"Parameter constructor (a={})\\n\", a); } LifetimeObserver([[maybe_unused]] const LifetimeObserver&amp; lto):a{lto.a} { fmt::print(\"Copy constructor (a={})\\n\", a); } LifetimeObserver([[maybe_unused]] const LifetimeObserver&amp;&amp; lto):a{lto.a} { fmt::print(\"Move constructor (a={})\\n\", a); } ~LifetimeObserver() { fmt::print(\"Destructor (a={})\\n\", a); }};auto main() -&gt; int { LifetimeObserver lto; LifetimeObserver lto1(99); LifetimeObserver lto2{lto1}; LifetimeObserver lto3{std::move(lto2)}; return 0;}When executed, this code produces this output:No parameter constructor (a=0)Parameter constructor (a=99)Copy constructor (a=99)Move constructor (a=99)Destructor (a=99)Destructor (a=99)Destructor (a=99)Destructor (a=0)We can see here how every constructor can be called to achieve our needs." }, { "title": "Hyperfine, a better version of time", "url": "/posts/Hyperfine/", "categories": "Sysadmin, Better CLI tools", "tags": "time, cli, bash, zsh", "date": "2022-09-12 18:30:00 +0200", "snippet": "Sick of boring time command? Sure, there is nothing very exciting about this one, even if it does its job quite well:Here is Hyperfine, a drop-in replacement for time written in Rust that offers way, way more features than plain ol’ time.Hyperfine can handle program warm-up, multiple runs, parameters for your benchmarks, cleanup and many more. It can even export its results in a JSON file! To me, the best alternative for time.Have fun!" }, { "title": "Setting up Intel SGX on Ubuntu", "url": "/posts/Setting-up-Intel-SGX/", "categories": "Sysadmin, Intel SGX", "tags": "intel, sgx, cli, bash, zsh", "date": "2022-09-12 18:00:00 +0200", "snippet": "Intel’s Software Guard Extension is a CPU instruction set that allows you to run sensitive code into an encrypted part of memory called an enclave.This enclave is completely isolated from the rest of running processes and cannot (in theory at least) be accessed by any other process that the one that created it, even by the OS itself.If I find enough time, I may write a post about how SGX works from a developper’s point of view.Anyway: using SGX implies a few addons to be installed on your computer.First: is your computer SGX-capable?There was a time where almost any Intel Core i7 CPU was SGX-capable, but in 2021 Intel shifted away from desktop-class CPU and reserved SGX to server-class CPUs. That made blu-ray lovers (and me btw) very angry.So to know if your CPU can make use of SGX enclaves, you can use the great test-sgx program. Basically, this program will retrieve some CPU information and read flags from it, telling you if your CPU supports SGX or not.It might be necessary to enable it from the BIOSIn all cases: follow the instructions provided in the repo’s READMEIf you only need the driver to run an SGX appIf you don’t want to dev using SGX and only need to run an SGX-enabled app, then you only need the driver. Scone, which is a secure container environment based on SGX, created a nice script that make the installation of this driver as easy as this one-liner:curl -fssl https://raw.githubusercontent.com/SconeDocs/SH/master/install_sgx_driver.sh | bashAs always, feel free to review the installer’s code before executing it.If you want to dev with SGX: the full setupOk the driver ain’t enough, and you want the full setup? Here is how to do it.First, install dependencies:apt updateapt upgrade -yapt install -y curl lsb-release build-essential ocaml ocamlbuild automake autoconf libtool wget libssl-dev git cmake perl libssl-dev libcurl4-openssl-dev protobuf-compiler libprotobuf-dev debhelper cmake reprepro unzipNothing fancy here. Next, we’re going to retrieve some OS values to be used later on:# get os name (18.10, 20.04...)version=$(lsb_release -sr)# get os codename (trusty, focal...)codename=$(lsb_release -sc)Ok next, using these variables, we are going to create a few more. The first one is the latest Intel SGX SDK’s version:sdk_version=$(git ls-remote --refs --tags https://github.com/intel/linux-sgx.git | cut -d '/' -f 3 | sort --version-sort | egrep \"^sgx_[0-9]\\.[0-9]+$\" | tail -1)sdk_version_short=$(echo $sdk_version | cut -c 5-)Then, from that we are going to create download URLs for the SDK’s repo, the driver and the SDK’s binary.# create repo URLrepo_url=https://download.01.org/intel-sgx/sgx-linux/${sdk_version_short}/distro/ubuntu${version}-server/# retrieve filenames from repo URLdriver_filename=$(curl -s $repo_url | grep -Po 'sgx_linux_x64_driver_[0-9a-z\\._]+\\.bin' | uniq | sort --reverse | head -1)sdk_filename=$(curl -s $repo_url | grep -Po 'sgx_linux_x64_sdk_[0-9a-z\\._]+\\.bin' | uniq)Now we’re ready to go: let’s create a temporary directory to download everything we need into:tmp_dir=$(mktemp -d)cd $tmp_dirLet’s clone the SDK’s repo and compile/install SGX tools:# clone SDK repogit clone https://github.com/intel/linux-sgx.git# compile SDK's toolset and copy it to system dircd linux-sgx &amp;&amp; make preparationcp external/toolset/ubuntu${version}/* /usr/local/bin# back to temp dircd $tmp_dirNext, let’s download SDK and driver binaries to install them:wget $repo_url$driver_filenamewget $repo_url$sdk_filenamechmod +x sgx_linux_x64_*mkdir -p /opt/intel/./sgx_linux_x64_sdk*.bin &lt;&lt; 'EOF'no/opt/intelEOF./sgx_linux_x64_driver*.binOk, almost there. Now we need to install a few more SGX services like AESM:echo \"deb [arch=amd64] https://download.01.org/intel-sgx/sgx_repo/ubuntu ${codename} main\" | tee /etc/apt/sources.list.d/intel-sgx.listwget -qO - https://download.01.org/intel-sgx/sgx_repo/ubuntu/intel-sgx-deb.key | apt-key add -apt updateapt install -y libsgx-launch libsgx-urts libsgx-epid libsgx-quote-ex libsgx-dcap-ql libsgx-uae-serviceFinally, cleanup the temp directory:rm -rf $tmp_dirYay, we’re done!For convenience, here is the complete script you can save to a file and sudo-execute:# install dependenciesapt updateapt upgrade -yapt install -y curl lsb-release build-essential ocaml ocamlbuild automake autoconf libtool wget libssl-dev git cmake perl libssl-dev libcurl4-openssl-dev protobuf-compiler libprotobuf-dev debhelper cmake reprepro unzip# get os name (18.10, 20.04...)version=$(lsb_release -sr)# get os codename (trusty, focal...)codename=$(lsb_release -sc)# retrieve latest version of SGX SDKsdk_version=$(git ls-remote --refs --tags https://github.com/intel/linux-sgx.git | cut -d '/' -f 3 | sort --version-sort | egrep \"^sgx_[0-9]\\.[0-9]+$\" | tail -1)sdk_version_short=$(echo $sdk_version | cut -c 5-)# create repo URLrepo_url=https://download.01.org/intel-sgx/sgx-linux/${sdk_version_short}/distro/ubuntu${version}-server/# retrieve filenames from repo URLdriver_filename=$(curl -s $repo_url | grep -Po 'sgx_linux_x64_driver_[0-9a-z\\._]+\\.bin' | uniq | sort --reverse | head -1)sdk_filename=$(curl -s $repo_url | grep -Po 'sgx_linux_x64_sdk_[0-9a-z\\._]+\\.bin' | uniq)# create temp repo and move to ittmp_dir=$(mktemp -d)cd $tmp_dir# clone SDK repogit clone https://github.com/intel/linux-sgx.git# compile SDK's toolset and copy it to system dircd linux-sgx &amp;&amp; make preparationcp external/toolset/ubuntu${version}/* /usr/local/bin# back to temp dircd $tmp_dir# download driver and SDKwget $repo_url$driver_filenamewget $repo_url$sdk_filename# mark both as executablechmod +x sgx_linux_x64_*# create directory for SDKmkdir -p /opt/intel/# on questions: \"no\" then \"/opt/intel\"./sgx_linux_x64_sdk*.bin &lt;&lt; 'EOF'no/opt/intelEOF# add SDK env vars to local shell environmentif [[ $SHELL = *zsh ]]; then echo \"source /opt/intel/sgxsdk/environment\" &gt;&gt; ~/.zshrcelse echo \"source /opt/intel/sgxsdk/environment\" &gt;&gt; ~/.bashrcfi# finally, install driver./sgx_linux_x64_driver*.bin# setup PSW repoecho \"deb [arch=amd64] https://download.01.org/intel-sgx/sgx_repo/ubuntu ${codename} main\" | tee /etc/apt/sources.list.d/intel-sgx.listwget -qO - https://download.01.org/intel-sgx/sgx_repo/ubuntu/intel-sgx-deb.key | apt-key add -# install PSW/AESM daemonapt updateapt install -y libsgx-launch libsgx-urts libsgx-epid libsgx-quote-ex libsgx-dcap-ql libsgx-uae-servicerm -rf $tmp_dirOne more thingOk, having a bash script that automates everything is fine, but what about an ansible script? You guessed it, I’ve got you covered. Here is a complete script that make all of the above and also sets up Gramine if you want to.Refer to the project’s README for more information.Have fun!" }, { "title": "Installing pCloud from CLI", "url": "/posts/Installing-pCloud-from-CLI/", "categories": "Sysadmin, CLI tricks", "tags": "pcloud, cli, bash, zsh", "date": "2022-09-04 19:02:00 +0200", "snippet": "Hi, CLI lovers.I’ve been maintaining a reinstall script for a while now. It allows me to setup effortlessly a new Mac.Until recently, I only had trouble when installing pCloud. Why? Because, as stated in this issue, its download URL is volatile. Why again? Because pCloud client is delivered by…pCloud itself.To retrieve the latest version of pCloud client, we must use pCloud’s API. So, without further ado, let’s dive in.Retrieving the API codeTo retrieve a publicly shared file from pCloud’s API, you must be in possession of its code. Luckily for us, this code is quite easy to retrieve. Head to pCloud download page and, when the download begins, cancel it.Now open the page source and scroll it a bit. You should find these lines near the top:There we have all the API codes we need. Our script thus need to retrieve this page, search and isolate the API code. We can do it using shell script:apicode=$(curl -s https://www.pcloud.com/how-to-install-pcloud-drive-mac-os.html\\?download\\=mac | grep \"'Mac':\" | sed \"s/[ ,:']*//g;s/Mac//g\" | tr -d '\\t')curl retrieves the page’s source, grep isolates the line containing ‘Mac’:, the we sed/tr out the unnecessary parts.Then, we have to call pCloud’s API to get the download URL.Calling pCloud’s APICalling pCloud’s API is not difficult. Just use the correct URL and pass the code we just got:url=\"https://api.pcloud.com/getpublinkdownload?code=${apicode}\"This API call will return a JSON array:{ \"result\":0, \"expires\":\"Mon, 14 Sep 2020 23:26:47 +0000\", \"dwltag\":\"CgbnCGd7SbJyIMLamlsatV\", \"path\":\"\\/cBZTQulgBZPr7SisZZZ3OgM37Z2ZZRw0ZkZvdbe7Z9FZM5ZWHZ9VZbVZ6FZ2FZVHZf7Zc7Zl7Z8XZu0ZrFZAgiVXZOr8pQSg6xa8qGE3QSr61Rj4XM9tX\\/pCloud%20Drive%203.9.5.pkg\", \"hosts\":[ \"p-par1.pcloud.com\", \"p-ams2.pcloud.com\" ]}Ok, we need to isolate two things: the path, and one of the hosts.Parsing JSON using shellWhen I use this script, I want to rely only on my shell’s default tools. Nothing fancy like jq (a CLI JSON parser) or anything else.So we will again sed/tr/grep our way out. It’s again quite simple though:# get path from which we will download pcloud.p=$(curl -s ${url} | grep path | sed 's/path//g;s/[\" :,]*//g;s|\\\\||g' | tr -d '\\t')# get a host. There might be more than one, get the first one.h=$(curl -s ${url} | grep .pcloud.com | head -1 | sed 's/[\" ,]*//g' | tr -d '\\t')They respectively retrieve the path and the first host.Now that we have everything we need, let’s download and install pCloud.Downloading and installingNow this is the easy part:# retrieve pcloudu=\"https://${h}${p}\"curl -s $u -o pcloud.pkg#install pCloudsudo -S installer -pkg pcloud.pkg -target /There you go! Have fun!" }, { "title": "New And Delete Are A Code Smell", "url": "/posts/new-and-delete-are-a-code-smell/", "categories": "", "tags": "", "date": "2020-12-16 00:00:00 +0100", "snippet": "" } ]
